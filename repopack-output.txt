================================================================
REPOPACK OUTPUT FILE
================================================================

This file was generated by Repopack on: 2024-08-24T00:25:25.931Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
   a. A separator line (================)
   b. The file path (File: path/to/file)
   c. Another separator line
   d. The full contents of the file
   e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
   original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
   distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
   the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation.


For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Files
================================================================

================
File: Documentation/Ideas/FlexibleMinimumStayPricing.md
================
# Flexible Minimum Stay with Increased Pricing

## Concept
Allow bookings shorter than the minimum stay requirement, provided guests pay the equivalent of the minimum stay price.

## Feature Overview
- Property-level option to "allow shorter stays with increased pricing"
- Guests can book for fewer nights than the minimum stay
- Charge based on the full minimum stay period, regardless of actual stay length

## Potential Benefits
1. Increased booking flexibility for guests
2. Higher occupancy rates
3. Maintained revenue for shorter stays
4. Attractive for business travelers or short-term needs

## Implementation Considerations
1. Property-level setting to enable/disable this feature
2. Clear pricing communication to guests
3. Possible absolute minimum stay threshold
4. Seasonal applicability
5. Integration with existing booking rules
6. Pricing display strategy

## Questions for Future Development
1. Applicability to all minimum stay rules or just general ones?
2. Impact on total price calculation
3. Restrictions on minimum stay length with this feature
4. Interaction with existing gap stay allowances
5. Potential for discounts on these shorter stays

## Next Steps
1. Define clear answers to the questions above
2. Determine exact desired behavior
3. Plan for clear user communication in the booking interface
4. Consider implications for pricing calculations and display
5. Evaluate potential impact on overall booking patterns and revenue

## Notes
This feature idea is currently on hold due to complexity. When revisiting, consider starting with a simplified version and iterating based on user feedback and operational impact.

================
File: PropertyMentor/asgi.py
================
"""
ASGI config for PropertyMentor project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'PropertyMentor.settings')

application = get_asgi_application()

================
File: PropertyMentor/settings.py
================
"""
Django settings for PropertyMentor project.

Generated by 'django-admin startproject' using Django 5.1.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-7(#!u=5kz@t%&^aevqm9^ea8-e7xe0e%$jxf@x30!i$qwixb3$'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'owners',
    'properties',
    'guests',
    'bookings'
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'PropertyMentor.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'PropertyMentor.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'Pacific/Auckland'

USE_I18N = True

USE_L10N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

================
File: PropertyMentor/urls.py
================
"""
URL configuration for PropertyMentor project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.1/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path

urlpatterns = [
    path('admin/', admin.site.urls),
]

================
File: PropertyMentor/wsgi.py
================
"""
WSGI config for PropertyMentor project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'PropertyMentor.settings')

application = get_wsgi_application()

================
File: README.md
================
# Short Term Rental Property Management System

This Django-based web application is designed to manage short-term rental properties, including owners, properties, guests, and bookings.

## Features

- Owner management
- Property listings
- Guest information
- Booking system

## Prerequisites

- Python 3.8+
- Django 3.2+

## Installation

1. Clone the repository:
   ```
   git clone https://github.com/hello-adam-martin/PropertyMentor
   cd PropertyMentor
   ```

2. Create a virtual environment and activate it:
   ```
   python -m venv venv
   source venv/bin/activate  # On Windows use `venv\Scripts\activate`
   ```

3. Install the required packages:
   ```
   pip install -r requirements.txt
   ```

4. Apply the migrations:
   ```
   python manage.py migrate
   ```

5. Create a superuser:
   ```
   python manage.py createsuperuser
   ```

6. Run the development server:
   ```
   python manage.py runserver
   ```

7. Open a web browser and navigate to `http://127.0.0.1:8000/admin/` to access the admin interface.

## Usage

[Provide brief instructions on how to use the main features of your application]

## Contributing

[Explain how others can contribute to your project]

## License

[Specify the license under which your project is released]

## Contact

[Adam Martin] - [hello.adam.martin@gmail.com]

Project Link: [https://github.com/hello-adam-martin/PropertyMentor](https://github.com/hello-adam-martin/PropertyMentor)

================
File: bookings/README.md
================
# Bookings App

This Django app manages bookings for the Short Term Rental Property Management system.

## Features

- Create, read, update, and delete bookings
- Automatic price calculation based on property pricing rules
- Booking validation to prevent conflicts and ensure logical date ranges
- Support for gap stays (shorter stays that fill gaps between existing bookings)
- Admin interface for managing bookings

## Models

### Booking

- `property`: ForeignKey to Property model
- `guest`: ForeignKey to Guest model
- `check_in_date`: Date of check-in
- `check_out_date`: Date of check-out
- `total_price`: Automatically calculated based on property pricing rules
- `status`: Booking status (pending, confirmed, cancelled, completed)
- `booking_date`: Date when the booking was created
- `special_requests`: Text field for any special requests

## Key Methods

- `calculate_price_breakdown()`: Calculates the price for each night of the stay
- `get_price_and_rule_for_date()`: Determines the price for a specific date based on pricing rules
- `calculate_total_price()`: Computes the total price for the entire stay
- `clean()`: Performs validation checks including overlapping bookings and adherence to booking rules

## Validation Rules

1. Check-out date must be after check-in date
2. Bookings cannot overlap with existing bookings for the same property
3. Bookings must adhere to the property's booking rules:
   - No check-ins on restricted days
   - No check-outs on restricted days
   - Minimum stay requirement (either default or date-specific)
4. Gap stays are allowed if the property permits them

## Price Calculation

The total price is automatically calculated based on the property's pricing rules, which can include:

- Base nightly rate
- Weekend pricing
- Seasonal pricing
- Override pricing for specific dates

## Admin Interface

The admin interface provides a customized view for managing bookings:

- List display shows key booking information
- Filters for status and dates
- Search functionality
- Read-only total price field
- Price breakdown display

## Usage

To create a new booking:

1. Go to the admin interface
2. Click on "Bookings" under the "Bookings" app
3. Click "Add Booking"
4. Fill in the required information
5. Save the booking

The system will automatically validate the booking, apply relevant pricing rules, and calculate the total price.

## Interaction with Property App

The Booking app relies on the Property app for:
- Property information
- Pricing rules
- Booking rules (minimum stay, no check-in/check-out days, gap stay settings)

Ensure that properties and their rules are correctly set up in the Property app for accurate booking calculations and validations.

## Future Enhancements

- Implement a public-facing booking interface
- Add email notifications for booking status changes
- Integrate with a payment system
- Implement a calendar view to visualize available dates and pricing
- Develop a more sophisticated gap stay handling system

================
File: bookings/admin.py
================
from django.contrib import admin
from .models import Booking
from django.utils.html import format_html

@admin.register(Booking)
class BookingAdmin(admin.ModelAdmin):
    list_display = ('property', 'guest', 'check_in_date', 'check_out_date', 'num_guests', 'base_total', 'fees_total', 'total_price', 'status')
    list_filter = ('status', 'check_in_date', 'check_out_date')
    search_fields = ('property__name', 'guest__first_name', 'guest__last_name', 'special_requests')
    readonly_fields = ('base_total', 'fees_total', 'total_price', 'price_breakdown')

    def price_breakdown(self, obj):
        if not obj.pk:  # If the object hasn't been saved yet
            return "Price breakdown will be available after saving."

        breakdown = obj.calculate_price_breakdown()
        if not breakdown:
            return "Unable to calculate price breakdown. Please ensure all required fields are filled."

        html = "<table><tr><th>Date</th><th>Price</th><th>Rule Applied</th></tr>"
        for day in breakdown:
            html += f"<tr><td>{day['date']}</td><td>${day['price']}</td><td>{day['rule_applied']}</td></tr>"
        html += f"<tr><td colspan='3'><strong>Base Total: ${obj.base_total}</strong></td></tr>"
        
        # Add fee breakdown
        fees = obj.property.fees.all()
        if fees:
            html += "<tr><td colspan='3'><strong>Fees:</strong></td></tr>"
            for fee in fees:
                fee_amount = obj.calculate_fee_amount(fee)
                html += f"<tr><td colspan='2'>{fee.name}</td><td>${fee_amount}</td></tr>"
        
        html += f"<tr><td colspan='3'><strong>Fees Total: ${obj.fees_total}</strong></td></tr>"
        html += f"<tr><td colspan='3'><strong>Grand Total: ${obj.total_price}</strong></td></tr>"
        html += "</table>"
        return format_html(html)
    price_breakdown.short_description = "Price Breakdown"

    def save_model(self, request, obj, form, change):
        obj.full_clean()  # This will run the validation and calculate the price
        super().save_model(request, obj, form, change)

    def get_readonly_fields(self, request, obj=None):
        if obj:  # If this is an existing object
            return self.readonly_fields
        return ('base_total', 'fees_total', 'total_price', 'price_breakdown')  # Make these fields readonly for new objects too

    def get_fieldsets(self, request, obj=None):
        fieldsets = super().get_fieldsets(request, obj)
        if obj is None:  # This is an add form
            fieldsets = [
                (None, {
                    'fields': ['property', 'guest', 'check_in_date', 'check_out_date', 'num_guests', 'status', 'special_requests']
                }),
            ]
        else:  # This is a change form
            fieldsets = [
                (None, {
                    'fields': ['property', 'guest', 'check_in_date', 'check_out_date', 'num_guests', 'status', 'special_requests']
                }),
                ('Price Information', {
                    'fields': ['base_total', 'fees_total', 'total_price', 'price_breakdown'],
                }),
            ]
        return fieldsets

================
File: bookings/apps.py
================
from django.apps import AppConfig


class BookingsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'bookings'

================
File: bookings/migrations/0001_initial.py
================
# Generated by Django 5.1 on 2024-08-22 18:19

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('guests', '0001_initial'),
        ('properties', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Booking',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('check_in_date', models.DateField()),
                ('check_out_date', models.DateField()),
                ('total_price', models.DecimalField(decimal_places=2, max_digits=10)),
                ('status', models.CharField(choices=[('pending', 'Pending'), ('confirmed', 'Confirmed'), ('cancelled', 'Cancelled'), ('completed', 'Completed')], default='pending', max_length=20)),
                ('booking_date', models.DateTimeField(auto_now_add=True)),
                ('special_requests', models.TextField(blank=True)),
                ('guest', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='bookings', to='guests.guest')),
                ('property', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='bookings', to='properties.property')),
            ],
            options={
                'ordering': ['-check_in_date'],
            },
        ),
    ]

================
File: bookings/migrations/0002_alter_booking_options.py
================
# Generated by Django 5.1 on 2024-08-22 18:52

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0001_initial'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='booking',
            options={'ordering': ['check_in_date']},
        ),
    ]

================
File: bookings/migrations/0003_alter_booking_total_price.py
================
# Generated by Django 5.1 on 2024-08-22 18:55

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0002_alter_booking_options'),
    ]

    operations = [
        migrations.AlterField(
            model_name='booking',
            name='total_price',
            field=models.DecimalField(decimal_places=2, editable=False, max_digits=10),
        ),
    ]

================
File: bookings/migrations/0004_alter_booking_options.py
================
# Generated by Django 5.1 on 2024-08-23 03:13

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0003_alter_booking_total_price'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='booking',
            options={'ordering': ['check_in_date'], 'verbose_name_plural': 'Bookings'},
        ),
    ]

================
File: bookings/migrations/0005_alter_booking_options.py
================
# Generated by Django 5.1 on 2024-08-23 05:23

from django.db import migrations


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0004_alter_booking_options'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='booking',
            options={'ordering': ['-check_in_date']},
        ),
    ]

================
File: bookings/migrations/0006_booking_base_total_booking_fees_total_and_more.py
================
# Generated by Django 5.1 on 2024-08-24 00:21

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('bookings', '0005_alter_booking_options'),
    ]

    operations = [
        migrations.AddField(
            model_name='booking',
            name='base_total',
            field=models.DecimalField(decimal_places=2, default=100, editable=False, max_digits=10),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name='booking',
            name='fees_total',
            field=models.DecimalField(decimal_places=2, default=100, editable=False, max_digits=10),
            preserve_default=False,
        ),
        migrations.AddField(
            model_name='booking',
            name='num_guests',
            field=models.PositiveIntegerField(default=4),
            preserve_default=False,
        ),
    ]

================
File: bookings/models.py
================
from django.db import models
from django.core.exceptions import ValidationError
from datetime import timedelta
from decimal import Decimal, ROUND_HALF_UP

class Booking(models.Model):
    property = models.ForeignKey('properties.Property', on_delete=models.CASCADE, related_name='bookings')
    guest = models.ForeignKey('guests.Guest', on_delete=models.CASCADE, related_name='bookings')
    check_in_date = models.DateField()
    check_out_date = models.DateField()
    num_guests = models.PositiveIntegerField()
    base_total = models.DecimalField(max_digits=10, decimal_places=2, editable=False)
    fees_total = models.DecimalField(max_digits=10, decimal_places=2, editable=False)
    total_price = models.DecimalField(max_digits=10, decimal_places=2, editable=False)
    status = models.CharField(max_length=20, choices=[
        ('pending', 'Pending'),
        ('confirmed', 'Confirmed'),
        ('cancelled', 'Cancelled'),
        ('completed', 'Completed')
    ], default='pending')
    booking_date = models.DateTimeField(auto_now_add=True)
    special_requests = models.TextField(blank=True)

    def calculate_price_breakdown(self):
        breakdown = []
        if self.check_in_date and self.check_out_date and self.property:
            current_date = self.check_in_date
            while current_date < self.check_out_date:
                price, rule_applied = self.get_price_and_rule_for_date(current_date)
                breakdown.append({
                    'date': current_date,
                    'price': price,
                    'rule_applied': rule_applied
                })
                current_date += timedelta(days=1)
        return breakdown

    def get_price_and_rule_for_date(self, date):
        if not self.property:
            return Decimal('0.00'), "No property selected"

        base_price = self.property.nightly_rate
        applicable_rules = []

        for rule in self.property.pricing_rules.all():
            if rule.rule_type == 'override' and rule.start_date == date:
                return self.round_price(base_price * rule.get_modifier_factor()), f"Override: {rule.price_modifier}%"
            elif rule.rule_type == 'seasonal' and rule.start_date <= date <= rule.end_date:
                applicable_rules.append(rule)
            elif rule.rule_type == 'weekend' and date.weekday() in [4, 5]:  # Friday and Saturday
                applicable_rules.append(rule)

        if applicable_rules:
            applicable_rules.sort(key=lambda x: (x.rule_type != 'seasonal', -x.price_modifier))
            applied_rule = applicable_rules[0]
            return self.round_price(base_price * applied_rule.get_modifier_factor()), f"{applied_rule.get_rule_type_display()}: {applied_rule.price_modifier}%"

        return self.round_price(base_price), "Base rate"

    def calculate_total_price(self):
        base_total = sum(Decimal(day['price']) for day in self.calculate_price_breakdown())
        fees_total = self.calculate_fees()
        return self.round_price(base_total + fees_total)

    def calculate_fees(self):
        total_fees = Decimal('0.00')
        nights = (self.check_out_date - self.check_in_date).days
        base_total = sum(Decimal(day['price']) for day in self.calculate_price_breakdown())

        for fee in self.property.fees.all():
            if fee.fee_type == 'percentage':
                fee_amount = base_total * (fee.amount / 100)
            else:  # fixed amount
                fee_amount = fee.amount

            if fee.applies == 'per_night':
                fee_amount *= nights
            
            if fee.is_extra_guest_fee and self.num_guests > fee.extra_guest_threshold:
                extra_guests = self.num_guests - fee.extra_guest_threshold
                fee_amount *= extra_guests

            total_fees += fee_amount

        return self.round_price(total_fees)

    @staticmethod
    def round_price(price):
        return Decimal(price).quantize(Decimal('0.01'), rounding=ROUND_HALF_UP)

    def clean(self):
        if not self.check_in_date:
            raise ValidationError("Check-in date is required.")
        if not self.check_out_date:
            raise ValidationError("Check-out date is required.")
        if not self.property:
            raise ValidationError("Property is required.")
        if not self.num_guests:
            raise ValidationError("Number of guests is required.")

        if self.check_out_date <= self.check_in_date:
            raise ValidationError("Check-out date must be after check-in date.")

        nights = (self.check_out_date - self.check_in_date).days

        overlapping_bookings = Booking.objects.filter(
            property=self.property,
            check_in_date__lt=self.check_out_date,
            check_out_date__gt=self.check_in_date
        ).exclude(pk=self.pk)

        if overlapping_bookings.exists():
            raise ValidationError("This booking overlaps with an existing booking.")

        # Check booking rules
        try:
            self.property.check_booking_rules(self.check_in_date, self.check_out_date)
        except ValidationError as e:
            raise ValidationError(str(e))

        self.base_total = self.round_price(sum(Decimal(day['price']) for day in self.calculate_price_breakdown()))
        self.fees_total = self.calculate_fees()
        self.total_price = self.base_total + self.fees_total

    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.guest} at {self.property} ({self.check_in_date} to {self.check_out_date})"

    class Meta:
        ordering = ['-check_in_date']

================
File: bookings/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: bookings/views.py
================
from django.shortcuts import render

# Create your views here.

================
File: guests/admin.py
================
from django.contrib import admin
from .models import Guest

@admin.register(Guest)
class GuestAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'email', 'phone', 'date_joined')
    list_filter = ('date_joined',)
    search_fields = ('first_name', 'last_name', 'email', 'phone')

================
File: guests/apps.py
================
from django.apps import AppConfig


class GuestsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'guests'

================
File: guests/migrations/0001_initial.py
================
# Generated by Django 5.1 on 2024-08-22 18:16

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Guest',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('first_name', models.CharField(max_length=50)),
                ('last_name', models.CharField(max_length=50)),
                ('email', models.EmailField(max_length=254, unique=True)),
                ('phone', models.CharField(max_length=15)),
                ('date_joined', models.DateField(auto_now_add=True)),
            ],
            options={
                'ordering': ['last_name', 'first_name'],
            },
        ),
    ]

================
File: guests/models.py
================
from django.db import models

class Guest(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=15)
    date_joined = models.DateField(auto_now_add=True)

    def __str__(self):
        return f"{self.first_name} {self.last_name}"

    class Meta:
        ordering = ['last_name', 'first_name']

================
File: guests/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: guests/views.py
================
from django.shortcuts import render

# Create your views here.

================
File: manage.py
================
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'PropertyMentor.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

================
File: owners/admin.py
================
from django.contrib import admin
from .models import Owner

@admin.register(Owner)
class OwnerAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'email', 'phone', 'date_joined')
    search_fields = ('first_name', 'last_name', 'email')
    list_filter = ('date_joined',)

================
File: owners/apps.py
================
from django.apps import AppConfig


class OwnersConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'owners'

================
File: owners/migrations/0001_initial.py
================
# Generated by Django 5.1 on 2024-08-22 13:17

from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Owner',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('first_name', models.CharField(max_length=50)),
                ('last_name', models.CharField(max_length=50)),
                ('email', models.EmailField(max_length=254, unique=True)),
                ('phone', models.CharField(max_length=15)),
                ('address', models.TextField()),
                ('date_joined', models.DateField(auto_now_add=True)),
            ],
        ),
    ]

================
File: owners/models.py
================
from django.db import models

class Owner(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=15)
    address = models.TextField()
    date_joined = models.DateField(auto_now_add=True)

    def __str__(self):
        return f"{self.first_name} {self.last_name}"

================
File: owners/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: owners/views.py
================
from django.shortcuts import render

# Create your views here.

================
File: properties/README.md
================
# Properties App

This Django app manages properties and their associated rules for the Short Term Rental Property Management system.

## Features

- Create, read, update, and delete properties
- Manage complex pricing rules for each property
- Define booking rules including minimum stay requirements
- Support for gap stays
- Flexible check-in and check-out day restrictions
- Calculate property prices based on date and applicable rules

## Models

### Property

- Basic information: name, address, owner, bedrooms, bathrooms, max occupancy, etc.
- `nightly_rate`: Base nightly rate
- `allow_gap_stays`: Boolean to allow bookings shorter than the minimum stay to fill gaps
- `no_checkin_days`: Days when check-in is not allowed
- `no_checkout_days`: Days when check-out is not allowed
- `minimum_stay`: Default minimum number of nights for a booking

#### Key Methods

- `get_price_for_date(date)`: Calculates the price for a specific date based on applicable pricing rules
- `check_booking_rules(check_in_date, check_out_date)`: Validates a booking against all applicable booking rules

### PricingRule

- `property`: ForeignKey to Property model
- `rule_type`: Type of pricing rule (weekend, seasonal, override)
- `start_date` and `end_date`: Date range for the rule (if applicable)
- `price_modifier`: Percentage modifier for the base price

### BookingRule

- `property`: ForeignKey to Property model
- `start_date` and `end_date`: Date range for the rule
- `min_nights`: Minimum number of nights required for bookings in this date range

## Pricing Logic

The system supports three types of pricing rules:

1. Override Pricing: Applied to a specific date (e.g., holidays, special events)
2. Seasonal Pricing: Applied to a date range
3. Weekend Pricing: Applied to specific days of the week (typically Friday and Saturday)

Rules are applied in the following order of precedence:
1. Override (highest priority)
2. Seasonal
3. Weekend
4. Base nightly rate (lowest priority)

## Booking Rules

The system supports several types of booking rules:

1. No Check-in Days: Prevents check-ins on specific days of the week
2. No Check-out Days: Prevents check-outs on specific days of the week
3. Minimum Stay: Sets a default minimum number of nights for bookings
4. Date-specific Minimum Stay: Sets a minimum number of nights for bookings during a specific date range

Gap stays are supported if enabled for a property, allowing bookings shorter than the minimum stay to fill gaps between existing bookings.

## Admin Customizations

The admin interface is customized to:
- Display key property information in the list view
- Allow inline editing of pricing rules and booking rules when editing a property
- Show pricing rules with clear percentage representations
- Provide an intuitive interface for setting no check-in and no check-out days

## Usage

To create a new property with rules:

1. Go to the admin interface
2. Click on "Properties" under the "Properties" app
3. Click "Add Property"
4. Fill in the basic property information
5. Set the default minimum stay and select any no check-in/check-out days
6. In the inline sections, add pricing rules and date-specific minimum stay rules as needed
7. Save the property

## Future Enhancements

- Implement a public-facing property listing interface
- Add support for property images
- Implement a calendar view to visualize pricing and availability over time
- Add support for amenities and property features
- Develop a more sophisticated gap stay pricing strategy

================
File: properties/admin.py
================
from django.contrib import admin
from django import forms
from .models import Property, PricingRule, BookingRule, Fee

class PropertyAdminForm(forms.ModelForm):
    no_checkin_days = forms.MultipleChoiceField(
        choices=Property.DAYS_OF_WEEK,
        widget=forms.CheckboxSelectMultiple,
        required=False
    )
    no_checkout_days = forms.MultipleChoiceField(
        choices=Property.DAYS_OF_WEEK,
        widget=forms.CheckboxSelectMultiple,
        required=False
    )

    class Meta:
        model = Property
        fields = '__all__'

    def clean_no_checkin_days(self):
        return ''.join(self.cleaned_data['no_checkin_days'])

    def clean_no_checkout_days(self):
        return ''.join(self.cleaned_data['no_checkout_days'])

class PricingRuleInline(admin.TabularInline):
    model = PricingRule
    extra = 1

class BookingRuleInline(admin.TabularInline):
    model = BookingRule
    extra = 1

class FeeInline(admin.TabularInline):
    model = Fee
    extra = 1

@admin.register(Property)
class PropertyAdmin(admin.ModelAdmin):
    form = PropertyAdminForm
    list_display = ('name', 'address', 'owner', 'bedrooms', 'bathrooms', 'nightly_rate', 'minimum_stay')
    list_filter = ('bedrooms', 'bathrooms', 'minimum_stay')
    search_fields = ('name', 'address', 'owner__first_name', 'owner__last_name')
    inlines = [PricingRuleInline, BookingRuleInline, FeeInline]

    def get_form(self, request, obj=None, **kwargs):
        form = super().get_form(request, obj, **kwargs)
        if obj:
            form.base_fields['no_checkin_days'].initial = list(obj.no_checkin_days)
            form.base_fields['no_checkout_days'].initial = list(obj.no_checkout_days)
        return form

@admin.register(Fee)
class FeeAdmin(admin.ModelAdmin):
    list_display = ('name', 'property', 'fee_type', 'applies', 'display_strategy', 'amount', 'is_extra_guest_fee')
    list_filter = ('fee_type', 'applies', 'display_strategy', 'is_extra_guest_fee')
    search_fields = ('name', 'property__name')

================
File: properties/apps.py
================
from django.apps import AppConfig


class PropertiesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'properties'

================
File: properties/migrations/0001_initial.py
================
# Generated by Django 5.1 on 2024-08-22 13:19

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('owners', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Property',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
                ('address', models.TextField()),
                ('bedrooms', models.PositiveIntegerField()),
                ('bathrooms', models.DecimalField(decimal_places=1, max_digits=3)),
                ('max_occupancy', models.PositiveIntegerField()),
                ('nightly_rate', models.DecimalField(decimal_places=2, max_digits=8)),
                ('description', models.TextField()),
                ('date_added', models.DateField(auto_now_add=True)),
                ('owner', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='properties', to='owners.owner')),
            ],
            options={
                'verbose_name_plural': 'Properties',
            },
        ),
    ]

================
File: properties/migrations/0002_pricingrule.py
================
# Generated by Django 5.1 on 2024-08-23 03:13

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('properties', '0001_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='PricingRule',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('rule_type', models.CharField(choices=[('weekend', 'Weekend Pricing'), ('seasonal', 'Seasonal Pricing'), ('holiday', 'Holiday Pricing')], max_length=10)),
                ('start_date', models.DateField(blank=True, null=True)),
                ('end_date', models.DateField(blank=True, null=True)),
                ('price_modifier', models.DecimalField(decimal_places=2, help_text='e.g., 1.5 for 50% increase, 0.8 for 20% discount', max_digits=5)),
                ('property', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='pricing_rules', to='properties.property')),
            ],
        ),
    ]

================
File: properties/migrations/0003_alter_pricingrule_price_modifier.py
================
# Generated by Django 5.1 on 2024-08-23 03:19

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('properties', '0002_pricingrule'),
    ]

    operations = [
        migrations.AlterField(
            model_name='pricingrule',
            name='price_modifier',
            field=models.DecimalField(decimal_places=2, help_text='Enter a percentage. E.g., 150 for 50% increase, 80 for 20% discount', max_digits=5),
        ),
    ]

================
File: properties/migrations/0004_alter_pricingrule_price_modifier.py
================
# Generated by Django 5.1 on 2024-08-23 03:24

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('properties', '0003_alter_pricingrule_price_modifier'),
    ]

    operations = [
        migrations.AlterField(
            model_name='pricingrule',
            name='price_modifier',
            field=models.DecimalField(decimal_places=2, help_text='Enter a percentage. E.g., 120 for 20% increase, 80 for 20% discount', max_digits=5),
        ),
    ]

================
File: properties/migrations/0005_alter_pricingrule_rule_type.py
================
# Generated by Django 5.1 on 2024-08-23 04:42

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('properties', '0004_alter_pricingrule_price_modifier'),
    ]

    operations = [
        migrations.AlterField(
            model_name='pricingrule',
            name='rule_type',
            field=models.CharField(choices=[('weekend', 'Weekend Pricing'), ('seasonal', 'Seasonal Pricing'), ('override', 'Override Pricing')], max_length=10),
        ),
    ]

================
File: properties/migrations/0006_bookingrule.py
================
# Generated by Django 5.1 on 2024-08-23 19:46

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('properties', '0005_alter_pricingrule_rule_type'),
    ]

    operations = [
        migrations.CreateModel(
            name='BookingRule',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('rule_type', models.CharField(choices=[('no_checkin', 'No Check-in'), ('no_checkout', 'No Check-out'), ('min_stay', 'Minimum Stay'), ('min_stay_period', 'Minimum Stay for Period'), ('gap_override', 'Gap Stay Override')], max_length=20)),
                ('start_date', models.DateField(blank=True, null=True)),
                ('end_date', models.DateField(blank=True, null=True)),
                ('days_of_week', models.CharField(blank=True, help_text='Comma-separated list of day numbers (0=Monday, 6=Sunday)', max_length=7)),
                ('min_nights', models.PositiveIntegerField(blank=True, null=True)),
                ('max_nights', models.PositiveIntegerField(blank=True, null=True)),
                ('property', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='booking_rules', to='properties.property')),
            ],
            options={
                'ordering': ['property', 'rule_type', 'start_date'],
            },
        ),
    ]

================
File: properties/migrations/0007_property_allow_gap_stays.py
================
# Generated by Django 5.1 on 2024-08-23 20:33

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('properties', '0006_bookingrule'),
    ]

    operations = [
        migrations.AddField(
            model_name='property',
            name='allow_gap_stays',
            field=models.BooleanField(default=True, help_text='Allow bookings shorter than the minimum stay to fill gaps between bookings'),
        ),
    ]

================
File: properties/migrations/0008_remove_bookingrule_days_of_week_and_more.py
================
# Generated by Django 5.1 on 2024-08-23 21:16

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('properties', '0007_property_allow_gap_stays'),
    ]

    operations = [
        migrations.RemoveField(
            model_name='bookingrule',
            name='days_of_week',
        ),
        migrations.RemoveField(
            model_name='bookingrule',
            name='max_nights',
        ),
        migrations.AddField(
            model_name='property',
            name='no_checkin_days',
            field=models.CharField(blank=True, help_text='Days when check-in is not allowed', max_length=7),
        ),
        migrations.AddField(
            model_name='property',
            name='no_checkout_days',
            field=models.CharField(blank=True, help_text='Days when check-out is not allowed', max_length=7),
        ),
        migrations.AlterField(
            model_name='bookingrule',
            name='rule_type',
            field=models.CharField(choices=[('min_stay', 'Minimum Stay'), ('min_stay_period', 'Minimum Stay for Period')], max_length=20),
        ),
    ]

================
File: properties/migrations/0009_alter_bookingrule_options_and_more.py
================
# Generated by Django 5.1 on 2024-08-23 21:22

import django.utils.timezone
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('properties', '0008_remove_bookingrule_days_of_week_and_more'),
    ]

    operations = [
        migrations.AlterModelOptions(
            name='bookingrule',
            options={'ordering': ['property', 'start_date']},
        ),
        migrations.RemoveField(
            model_name='bookingrule',
            name='rule_type',
        ),
        migrations.AddField(
            model_name='property',
            name='minimum_stay',
            field=models.PositiveIntegerField(default=1, help_text='Minimum number of nights required for a booking'),
        ),
        migrations.AlterField(
            model_name='bookingrule',
            name='end_date',
            field=models.DateField(default=django.utils.timezone.now),
            preserve_default=False,
        ),
        migrations.AlterField(
            model_name='bookingrule',
            name='min_nights',
            field=models.PositiveIntegerField(default=2),
            preserve_default=False,
        ),
        migrations.AlterField(
            model_name='bookingrule',
            name='start_date',
            field=models.DateField(default=django.utils.timezone.now),
            preserve_default=False,
        ),
    ]

================
File: properties/migrations/0010_fee.py
================
# Generated by Django 5.1 on 2024-08-24 00:14

import django.core.validators
import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('properties', '0009_alter_bookingrule_options_and_more'),
    ]

    operations = [
        migrations.CreateModel(
            name='Fee',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
                ('fee_type', models.CharField(choices=[('percentage', 'Percentage'), ('fixed', 'Fixed Amount')], max_length=10)),
                ('applies', models.CharField(choices=[('per_night', 'Every Night'), ('once', 'Once per Stay')], max_length=10)),
                ('display_strategy', models.CharField(choices=[('separate', 'Show Separately'), ('incorporated', 'Incorporate into Price')], max_length=12)),
                ('amount', models.DecimalField(decimal_places=2, max_digits=10, validators=[django.core.validators.MinValueValidator(0)])),
                ('is_extra_guest_fee', models.BooleanField(default=False)),
                ('extra_guest_threshold', models.PositiveIntegerField(blank=True, null=True)),
                ('property', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='fees', to='properties.property')),
            ],
            options={
                'unique_together': {('property', 'name')},
            },
        ),
    ]

================
File: properties/models.py
================
from django.db import models
from django.core.exceptions import ValidationError
from owners.models import Owner
from decimal import Decimal
from django.core.validators import MinValueValidator

class PricingRule(models.Model):
    RULE_TYPES = [
        ('weekend', 'Weekend Pricing'),
        ('seasonal', 'Seasonal Pricing'),
        ('override', 'Override Pricing'),
    ]

    property = models.ForeignKey('Property', on_delete=models.CASCADE, related_name='pricing_rules')
    rule_type = models.CharField(max_length=10, choices=RULE_TYPES)
    start_date = models.DateField(null=True, blank=True)
    end_date = models.DateField(null=True, blank=True)
    price_modifier = models.DecimalField(
        max_digits=5, 
        decimal_places=2, 
        help_text="Enter a percentage. E.g., 120 for 20% increase, 80 for 20% discount"
    )

    def clean(self):
        if self.rule_type == 'seasonal' and (not self.start_date or not self.end_date):
            raise ValidationError("Seasonal pricing must have start and end dates.")
        if self.rule_type == 'override' and not self.start_date:
            raise ValidationError("Override pricing must have a start date.")
        if self.start_date and self.end_date and self.start_date > self.end_date:
            raise ValidationError("End date must be after start date.")
        if self.price_modifier <= 0:
            raise ValidationError("Price modifier must be greater than 0.")

    def __str__(self):
        return f"{self.get_rule_type_display()} for {self.property} ({self.price_modifier}%)"

    def get_modifier_factor(self):
        return self.price_modifier / Decimal('100')

class BookingRule(models.Model):
    property = models.ForeignKey('Property', on_delete=models.CASCADE, related_name='booking_rules')
    start_date = models.DateField()
    end_date = models.DateField()
    min_nights = models.PositiveIntegerField()

    def clean(self):
        if self.start_date >= self.end_date:
            raise ValidationError("End date must be after start date.")
        if self.min_nights <= 0:
            raise ValidationError("Minimum nights must be a positive number.")

    def __str__(self):
        return f"Minimum stay of {self.min_nights} nights for {self.property} from {self.start_date} to {self.end_date}"

    class Meta:
        ordering = ['property', 'start_date']

class Fee(models.Model):
    FEE_TYPES = [
        ('percentage', 'Percentage'),
        ('fixed', 'Fixed Amount'),
    ]
    APPLIES_OPTIONS = [
        ('per_night', 'Every Night'),
        ('once', 'Once per Stay'),
    ]
    DISPLAY_STRATEGIES = [
        ('separate', 'Show Separately'),
        ('incorporated', 'Incorporate into Price'),
    ]

    property = models.ForeignKey('Property', on_delete=models.CASCADE, related_name='fees')
    name = models.CharField(max_length=100)
    fee_type = models.CharField(max_length=10, choices=FEE_TYPES)
    applies = models.CharField(max_length=10, choices=APPLIES_OPTIONS)
    display_strategy = models.CharField(max_length=12, choices=DISPLAY_STRATEGIES)
    amount = models.DecimalField(max_digits=10, decimal_places=2, validators=[MinValueValidator(0)])
    is_extra_guest_fee = models.BooleanField(default=False)
    extra_guest_threshold = models.PositiveIntegerField(null=True, blank=True)

    def clean(self):
        from django.core.exceptions import ValidationError
        if self.is_extra_guest_fee and self.extra_guest_threshold is None:
            raise ValidationError("Extra guest threshold must be set for extra guest fees.")
        if not self.is_extra_guest_fee and self.extra_guest_threshold is not None:
            raise ValidationError("Extra guest threshold should only be set for extra guest fees.")

    def __str__(self):
        return f"{self.name} for {self.property}"

    class Meta:
        unique_together = ('property', 'name')

class Property(models.Model):
    WEEKEND_DAYS = [4, 5]  # Friday and Saturday
    DAYS_OF_WEEK = [
        (0, 'Monday'),
        (1, 'Tuesday'),
        (2, 'Wednesday'),
        (3, 'Thursday'),
        (4, 'Friday'),
        (5, 'Saturday'),
        (6, 'Sunday'),
    ]

    name = models.CharField(max_length=100)
    address = models.TextField()
    owner = models.ForeignKey(Owner, on_delete=models.CASCADE, related_name='properties')
    bedrooms = models.PositiveIntegerField()
    bathrooms = models.DecimalField(max_digits=3, decimal_places=1)
    max_occupancy = models.PositiveIntegerField()
    nightly_rate = models.DecimalField(max_digits=8, decimal_places=2)
    description = models.TextField()
    date_added = models.DateField(auto_now_add=True)

    allow_gap_stays = models.BooleanField(default=True, help_text="Allow bookings shorter than the minimum stay to fill gaps between bookings")
    no_checkin_days = models.CharField(max_length=7, blank=True, help_text="Days when check-in is not allowed")
    no_checkout_days = models.CharField(max_length=7, blank=True, help_text="Days when check-out is not allowed")
    minimum_stay = models.PositiveIntegerField(default=1, help_text="Minimum number of nights required for a booking")

    @property
    def total_fees(self):
        return self.fees.count()

    def __str__(self):
        return self.name
    
    def get_price_for_date(self, date):
        base_price = self.nightly_rate
        applicable_rules = []

        for rule in self.pricing_rules.all():
            if rule.rule_type == 'override' and rule.start_date == date:
                return base_price * rule.get_modifier_factor()  # Highest priority, return immediately
            elif rule.rule_type == 'seasonal' and rule.start_date <= date <= rule.end_date:
                applicable_rules.append(rule)
            elif rule.rule_type == 'weekend' and date.weekday() in self.WEEKEND_DAYS:
                applicable_rules.append(rule)

        if applicable_rules:
            # Sort by rule type (seasonal before weekend) and then by modifier (highest modifier first)
            applicable_rules.sort(key=lambda x: (x.rule_type != 'seasonal', -x.price_modifier))
            return base_price * applicable_rules[0].get_modifier_factor()

        return base_price
    
    def check_booking_rules(self, check_in_date, check_out_date):
        nights = (check_out_date - check_in_date).days
        
        # Check no check-in and no check-out rules
        if str(check_in_date.weekday()) in self.no_checkin_days:
            raise ValidationError(f"Check-in is not allowed on {check_in_date.strftime('%A')}s for this property.")
        
        if str(check_out_date.weekday()) in self.no_checkout_days:
            raise ValidationError(f"Check-out is not allowed on {check_out_date.strftime('%A')}s for this property.")

        # Check minimum stay rules
        min_stay = self.minimum_stay
        for rule in self.booking_rules.all():
            if rule.start_date <= check_in_date <= rule.end_date:
                min_stay = max(min_stay, rule.min_nights)
                break

        if nights < min_stay:
            if self.allow_gap_stays:
                prev_booking = self.bookings.filter(check_out_date__lte=check_in_date).order_by('-check_out_date').first()
                next_booking = self.bookings.filter(check_in_date__gte=check_out_date).order_by('check_in_date').first()
                
                if prev_booking and next_booking:
                    gap_size = (next_booking.check_in_date - prev_booking.check_out_date).days
                    if nights == gap_size:
                        # This is a valid gap stay
                        return
            
            # If we get here, it's not a valid booking
            raise ValidationError(f"Booking does not meet minimum stay requirement of {min_stay} nights and is not a valid gap stay.")

    class Meta:
        verbose_name_plural = "Properties"

================
File: properties/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: properties/views.py
================
from django.shortcuts import render

# Create your views here.

================
File: requirements.txt
================
asgiref==3.8.1
Django==5.1
sqlparse==0.5.1
